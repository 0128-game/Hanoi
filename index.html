<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒãƒã‚¤ã®å¡” - âš”ï¸ ãƒœãƒƒãƒˆå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰</title>
    <style>
        /* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f9;
            color: #333;
        }

        h1 {
            margin-bottom: 10px;
        }

        /* ç›¤é¢ã‚³ãƒ³ãƒ†ãƒŠã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå·¦å³åˆ†å‰²ï¼‰ */
        .game-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            width: 100%;
            height: 300px; 
            border-bottom: 5px solid #333;
        }

        .peg {
            position: relative;
            width: 30%;
            height: 100%;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
        }

        .peg.player-peg {
            cursor: pointer; 
        }
        .peg.bot-peg {
            cursor: default; 
        }

        .peg-base {
            position: absolute;
            bottom: 0;
            width: 8px;
            height: 100%;
            background-color: #555;
            z-index: 1;
        }

        .disk {
            position: relative;
            border-radius: 5px;
            margin-bottom: 2px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            cursor: default;
            transition: transform 0.15s, background-color 0.1s; 
            z-index: 2;
        }

        .disk.selected {
            transform: translateY(-50px) scale(1.05);
            border: 3px solid black;
            box-sizing: border-box;
        }

        #controls {
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            width: 100%;
            max-width: 800px;
            margin-top: 20px;
        }
        
        /* Pè¦ç´ ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºï¼‰ã¯æ¨ªã„ã£ã±ã„ã«ä½¿ã† */
        #controls p, #controls label {
            width: 100%;
            margin-bottom: 5px;
            text-align: center;
        }
        
        /* ãƒœã‚¿ãƒ³ã¨é¸æŠè¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        button, select, input[type="number"] {
            padding: 8px 12px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 5px 10px 5px;
            box-sizing: border-box;
            display: inline-block;
        }
        
        /* å®Ÿè¡Œãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #execute-button {
            background-color: #007bff;
            color: white;
            border: 1px solid #007bff;
            transition: background-color 0.2s;
        }
        #execute-button:hover {
            background-color: #0056b3;
        }
        
        /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #reset-button {
            background-color: #ffc107;
            color: #212529;
            border: 1px solid #ffc107;
            transition: background-color 0.2s;
        }
        #reset-button:hover {
            background-color: #e0a800;
        }


        /* ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒªã‚¹ãƒˆã®CSSä¿®æ­£ */
        select {
            border: 1px solid #ccc;
            background-color: white;
            padding: 7px 10px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            /* ã‚«ã‚¹ã‚¿ãƒ ã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³çŸ¢å° */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" fill="%23333"><polygon points="0,0 10,0 5,10"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 25px;
        }
        
        /* å††ç›¤æ•°ã®å…¥åŠ›æ¬„ã®å¹…ã‚’èª¿æ•´ */
        input[type="number"] {
             width: 60px;
             padding: 7px 5px;
        }

        #message {
            font-weight: bold;
            margin-top: 10px;
            color: #007bff;
        }

        /* ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .best-time-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 1em;
            text-align: left;
            margin: 0 auto;
        }
        .best-time-table th, .best-time-table td {
            padding: 8px 12px;
            border: 1px solid #ddd;
        }
        .best-time-table th {
            background-color: #f2f2f2;
            color: #333;
        }
    </style>
</head>
<body>

    <h1>ãƒãƒã‚¤ã®å¡” âš”ï¸ å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰</h1>

    <div id="game-containers-wrapper" style="display: flex; justify-content: space-around; width: 90%; margin: 20px 0;">
        
        <div id="player-container" style="width: 100%; border: 2px solid #007bff; border-radius: 8px; padding-top: 20px;">
            <h3 style="text-align: center; color: #007bff;">ğŸ§‘ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¤é¢</h3>
            <div id="game-container-player" class="game-container">
                <div id="peg1" class="peg player-peg">
                    <div class="peg-base"></div>
                </div>
                <div id="peg2" class="peg player-peg">
                    <div class="peg-base"></div>
                </div>
                <div id="peg3" class="peg player-peg">
                    <div class="peg-base"></div>
                </div>
            </div>
        </div>

        <div id="bot-container" style="width: 48%; border: 2px solid #dc3545; border-radius: 8px; padding-top: 20px; display: none;">
            <h3 style="text-align: center; color: #dc3545;">ğŸ¤– ãƒœãƒƒãƒˆã®ç›¤é¢</h3>
            <div id="game-container-bot" class="game-container">
                <div id="bot-peg1" class="peg bot-peg">
                    <div class="peg-base"></div>
                </div>
                <div id="bot-peg2" class="peg bot-peg">
                    <div class="peg-base"></div>
                </div>
                <div id="bot-peg3" class="peg bot-peg">
                    <div class="peg-base"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="controls">
        <div style="width: 100%; display: flex; justify-content: center; flex-wrap: wrap; gap: 10px;">
            <label for="disks" style="width: auto;">å††ç›¤ã®æ•° (3-64):</label> 
            <input type="number" id="disks" value="3" min="3" max="64">
        </div>

        <div style="width: 100%; display: flex; justify-content: center; flex-wrap: wrap; gap: 10px;">
            <button id="execute-button" onclick="executeAction()">ã‚²ãƒ¼ãƒ é–‹å§‹ï¼</button>
            <button id="reset-button" onclick="resetGame()">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>

        <div style="width: 100%; display: flex; justify-content: center; flex-wrap: wrap; gap: 10px;">
            <label for="game-mode" style="width: auto; color: #6a0dad; font-weight: bold;">ãƒ¢ãƒ¼ãƒ‰é¸æŠ:</label>
            <select id="game-mode" onchange="updateModeDisplay()">
                <option value="manual" selected>ãƒœãƒƒãƒˆãªã— (æ‰‹å‹•)</option>
                <option value="bot_only">ãƒœãƒƒãƒˆ (è‡ªå‹•ã‚¯ãƒªã‚¢)</option>
                <option value="versus">ãƒœãƒƒãƒˆã¨å¯¾æˆ¦</option>
            </select>
            
            <div id="bot-speed-controls" style="display: flex; gap: 10px; align-items: center;">
                <label for="bot-speed" style="width: auto; color: #007bff; font-weight: bold;">ãƒœãƒƒãƒˆé€Ÿåº¦:</label>
                <select id="bot-speed">
                    <option value="500">é…ã„ (0.5ç§’)</option>
                    <option value="300">æ¨™æº– (0.3ç§’)</option>
                    <option value="150">é€Ÿã„ (0.15ç§’)</option>
                    <option value="10">å‡¦ç†é™ç•Œ (0.01ç§’)</option>
                    <option value="0">è¶…é«˜é€Ÿã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</option> 
                </select>
            </div>
        </div>
        
        <p id="rate-display" style="display: none;">ç¾åœ¨ã®ãƒ¬ãƒ¼ãƒˆ: <span id="player-rate">1000</span></p>
        <p id="message">ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã€å††ç›¤ã®æ•°ã¨é€Ÿåº¦ã‚’è¨­å®šã—ã¦å®Ÿè¡Œã¾ãŸã¯ãƒªã‚»ãƒƒãƒˆã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
        <p>æ‰‹æ•°: <span id="moves">0</span> / æœ€å°æ‰‹æ•°: <span id="min-moves"></span></p>
        <p>çµŒéæ™‚é–“: <span id="time-elapsed">00:00.00</span></p>
        <p>ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ  (ç¾è¡Œå††ç›¤æ•°): <span id="best-time">---</span></p>
    </div>

    <button onclick="displayBestTimes()" style="margin-top: 20px;">å…¨ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ ã‚’è¡¨ç¤º/æ›´æ–°</button>
    <div id="best-time-list-container" style="margin-top: 15px; width: 90%; max-width: 500px;">
        </div>

    <script>
        // JS
        
        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨å®šæ•° ---
        let disksCount = 3;
        let selectedDisk = null;
        let sourcePegIndex = -1;
        let moves = 0;
        let minMoves = 0;
        let timerInterval = null;
        let startTime = 0;
        let isTimerRunning = false;
        let isBotRunning = false;
        let moveQueue = [];
        let playerWon = false;
        let botWon = false;
        let botHandicapMoves = 0; 
        let currentBotSpeedMs = 300; // â˜…æ–°è¦: ç¾åœ¨ã®ãƒœãƒƒãƒˆé€Ÿåº¦ã‚’ä¿æŒã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°

        // ãƒ¬ãƒ¼ãƒˆé–¢é€£
        const RATE_K = 16; 
        let playerRate = parseInt(localStorage.getItem('hanoi_player_rate') || '1000', 10);
        
        // ç›¤é¢çŠ¶æ…‹
        let playerPegsState = [[], [], []]; 
        let botPegsState = [[], [], []]; 
        let botInterval = null;

        // DOMè¦ç´ 
        const playerPegElements = [
            document.getElementById('peg1'),
            document.getElementById('peg2'),
            document.getElementById('peg3')
        ];
        const botPegElements = [
            document.getElementById('bot-peg1'),
            document.getElementById('bot-peg2'),
            document.getElementById('bot-peg3')
        ];
        const movesDisplay = document.getElementById('moves');
        const minMovesDisplay = document.getElementById('min-moves');
        const messageDisplay = document.getElementById('message');
        const disksInput = document.getElementById('disks');
        const timeDisplay = document.getElementById('time-elapsed');
        const bestTimeDisplay = document.getElementById('best-time');
        const botSpeedSelect = document.getElementById('bot-speed'); 
        const gameModeSelect = document.getElementById('game-mode');
        const rateDisplayElement = document.getElementById('player-rate');
        const botContainer = document.getElementById('bot-container'); 
        const wrapper = document.getElementById('game-containers-wrapper');
        const playerContainer = document.getElementById('player-container');
        const executeButton = document.getElementById('execute-button'); 
        const botSpeedControls = document.getElementById('bot-speed-controls');

        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚­ãƒ¼
        const STORAGE_KEY_BOT_SPEED = 'hanoi_bot_speed';

        // ç‰©ç†å®šæ•°
        const PEG_HEIGHT = 300;
        const DISK_MARGIN = 2;
        const MAX_PRACTICAL_DISKS = 64; 

        // --- ã‚¤ãƒ™ãƒ³ãƒˆã¨åˆæœŸåŒ– ---

        window.onload = () => {
            disksInput.setAttribute('max', MAX_PRACTICAL_DISKS);
            rateDisplayElement.textContent = playerRate;
            document.addEventListener('keydown', handleKeyPress);
            playerPegElements.forEach(peg => {
                peg.addEventListener('click', handleClickPeg);
            });
            
            loadAndSetBotSpeed();
            botSpeedSelect.addEventListener('change', saveBotSpeed);
            
            updateModeDisplay(); 
        };
        
        /**
         * ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ãƒœãƒƒãƒˆé€Ÿåº¦ã‚’èª­ã¿è¾¼ã¿ã€ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã«è¨­å®šã™ã‚‹
         */
        function loadAndSetBotSpeed() {
            const storedSpeed = localStorage.getItem(STORAGE_KEY_BOT_SPEED);
            
            if (storedSpeed) {
                const optionExists = Array.from(botSpeedSelect.options).some(option => option.value === storedSpeed);
                if (optionExists) {
                    botSpeedSelect.value = storedSpeed;
                } else {
                    botSpeedSelect.value = '300'; 
                }
            } else {
                botSpeedSelect.value = '300'; 
            }
        }
        
        /**
         * ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«ãƒœãƒƒãƒˆé€Ÿåº¦ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã™ã‚‹
         */
        function saveBotSpeed() {
            localStorage.setItem(STORAGE_KEY_BOT_SPEED, botSpeedSelect.value);
        }

        function executeAction() {
            const mode = gameModeSelect.value;
            if (mode === 'manual') {
                initGame();
                messageDisplay.textContent = "æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰é–‹å§‹ï¼æœ€åˆã®ç§»å‹•ã§ã‚¿ã‚¤ãƒãƒ¼ãŒã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã™ã€‚";
            } else {
                startBot();
            }
        }

        function resetGame() {
            if (botInterval) {
                clearInterval(botInterval);
            }
            stopTimer();
            isBotRunning = false;
            playerWon = false;
            botWon = false;
            moveQueue = [];
            botHandicapMoves = 0; 
            currentBotSpeedMs = 300; 
            
            initGame();
            messageDisplay.textContent = "ğŸ”„ ã‚²ãƒ¼ãƒ ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã€å††ç›¤ã®æ•°ã¨é€Ÿåº¦ã‚’è¨­å®šã—ã¦å®Ÿè¡Œã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚";
        }


        function updateModeDisplay() {
            const mode = gameModeSelect.value;
            const rateRow = document.getElementById('rate-display');
            let buttonLabel = '';
            
            if (mode === 'versus') {
                botSpeedControls.style.display = 'none'; 
                rateRow.style.display = 'block';
                buttonLabel = 'å¯¾æˆ¦é–‹å§‹ï¼';
                wrapper.style.maxWidth = '1000px'; 
                playerContainer.style.width = '48%'; 
                botContainer.style.display = 'block'; 
            } else if (mode === 'bot_only') {
                botSpeedControls.style.display = 'flex'; 
                rateRow.style.display = 'none';
                buttonLabel = 'ãƒœãƒƒãƒˆèµ·å‹•ï¼';
                wrapper.style.maxWidth = '90%'; 
                playerContainer.style.width = '100%'; 
                botContainer.style.display = 'none'; 
            } else { 
                botSpeedControls.style.display = 'none'; 
                rateRow.style.display = 'none';
                buttonLabel = 'ã‚²ãƒ¼ãƒ é–‹å§‹ï¼';
                wrapper.style.maxWidth = '90%'; 
                playerContainer.style.width = '100%'; 
                botContainer.style.display = 'none'; 
            }
            
            executeButton.textContent = buttonLabel;
            initGame();
        }

        /**
        * ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ– (ç›¤é¢ãƒªã‚»ãƒƒãƒˆã¨å††ç›¤é…ç½®)
        */
        function initGame() {
            if(botInterval) clearInterval(botInterval); 

            let newDisksCount = parseInt(disksInput.value);
            
            if (isNaN(newDisksCount) || newDisksCount < 3 || newDisksCount > MAX_PRACTICAL_DISKS) {
                alert(`å††ç›¤ã®æ•°ã¯3ã‹ã‚‰${MAX_PRACTICAL_DISKS}ã®é–“ã§è¨­å®šã—ã¦ãã ã•ã„ã€‚3æšã«æˆ»ã—ã¾ã™ã€‚`);
                disksCount = 3;
                disksInput.value = 3;
            } else {
                disksCount = newDisksCount;
            }

            minMoves = Math.pow(2, disksCount) - 1;
            let minMovesStr = minMoves.toString();
            if (disksCount > 25) { 
                minMovesStr = `2^${disksCount} - 1`;
            } else if (minMovesStr.length > 15) {
                minMovesStr = minMoves.toExponential(2);
            }

            resetSelection();
            moves = 0;
            movesDisplay.textContent = moves;
            minMovesDisplay.textContent = minMovesStr;

            playerWon = false;
            botWon = false;
            isBotRunning = false; 
            moveQueue = []; 
            botHandicapMoves = 0;

            resetTimerDisplay();
            isTimerRunning = false;
            
            const currentBestTimeMs = getBestTime(disksCount);
            bestTimeDisplay.textContent = formatTime(currentBestTimeMs);

            playerPegElements.forEach(peg => {
                peg.querySelectorAll('.disk').forEach(disk => disk.remove());
            });
            botPegElements.forEach(peg => {
                peg.querySelectorAll('.disk').forEach(disk => disk.remove());
            });
            
            playerPegsState = [[], [], []]; 
            botPegsState = [[], [], []]; 

            const totalMarginHeight = (disksCount - 1) * DISK_MARGIN;
            const availableHeight = PEG_HEIGHT - totalMarginHeight;
            const diskHeight = Math.floor(availableHeight / disksCount);

            const MIN_WIDTH = 50;
            const MAX_WIDTH = 180;
            const widthRange = MAX_WIDTH - MIN_WIDTH;

            const gameMode = gameModeSelect.value;
            
            for (let i = disksCount; i >= 1; i--) {
                const diskWidth = MIN_WIDTH + ((i - 1) / (disksCount - 1 || 1)) * widthRange;
                const hue = (i / disksCount) * 360;

                const pDisk = document.createElement('div');
                pDisk.classList.add('disk', 'player-disk');
                pDisk.dataset.size = i;
                pDisk.style.width = `${diskWidth}px`;
                pDisk.style.height = `${diskHeight}px`;
                pDisk.style.backgroundColor = `hsl(${hue}, 80%, 50%)`;
                playerPegElements[0].appendChild(pDisk);
                playerPegsState[0].push(i);

                if (gameMode === 'versus') {
                    const bDisk = document.createElement('div');
                    bDisk.classList.add('disk', 'bot-disk');
                    bDisk.dataset.size = i;
                    bDisk.style.width = `${diskWidth}px`;
                    bDisk.style.height = `${diskHeight}px`;
                    bDisk.style.backgroundColor = `hsl(${hue}, 80%, 50%)`;
                    botPegElements[0].appendChild(bDisk);
                    botPegsState[0].push(i);
                }
            }

            // â˜…ä¿®æ­£ç‚¹: å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒœãƒƒãƒˆé€Ÿåº¦ã¨æ‰‹æ•°ãƒãƒ³ãƒ‡ã®è¨ˆç®—
            if (gameMode === 'versus') {
                const rateMin = 500;
                const rateMax = 1500;
                
                // 1. ãƒœãƒƒãƒˆé€Ÿåº¦ã®è¨ˆç®—
                const maxSpeedMs = 500; 
                const minSpeedMs = 10;  
                
                let normalizedRate = Math.min(rateMax, Math.max(rateMin, playerRate));
                const rateRatio = (normalizedRate - rateMin) / (rateMax - rateMin); 
                
                let botSpeed = maxSpeedMs - rateRatio * (maxSpeedMs - minSpeedMs);
                currentBotSpeedMs = Math.round(Math.max(minSpeedMs, botSpeed)); // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä¿å­˜
                
                // 2. ãƒœãƒƒãƒˆã®æ‰‹æ•°ãƒãƒ³ãƒ‡ã®è¨ˆç®—
                const maxHandicapRatio = 0.20; 
                const handicapRatio = maxHandicapRatio * (1 - rateRatio); 
                
                // â˜…ä¿®æ­£ç‚¹: Math.round()ã§æ•´æ•°ã«ä¸¸ã‚ã‚‹
                const addedMoves = Math.round(minMoves * handicapRatio); 
                botHandicapMoves = addedMoves;

                const botTotalMoves = minMoves + addedMoves;

                messageDisplay.textContent = `âš”ï¸ å¯¾æˆ¦æº–å‚™å®Œäº†ï¼ç¾åœ¨ã®ãƒ¬ãƒ¼ãƒˆ ${playerRate}ã€‚ãƒœãƒƒãƒˆã¯ ${botTotalMoves}æ‰‹ (${addedMoves}æ‰‹ãƒãƒ³ãƒ‡) ã¨é€Ÿåº¦ ${currentBotSpeedMs}ms ã§ç«¶ã„ã¾ã™ã€‚å®Ÿè¡Œãƒœã‚¿ãƒ³ã§é–‹å§‹ã€‚`;
            } else if (gameMode === 'bot_only') {
                 messageDisplay.textContent = `ğŸ¤– ãƒœãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰: å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨è‡ªå‹•è§£æ±ºã‚’é–‹å§‹ã—ã¾ã™ã€‚`;
            } else {
                 messageDisplay.textContent = `æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰: å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦æº–å‚™å®Œäº†ã€‚æœ€åˆã®ç§»å‹•ã§ã‚¿ã‚¤ãƒãƒ¼ãŒã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã™ã€‚`;
            }
        }

        // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œ ---

        function handleClickPeg(event) {
            if (isBotRunning && gameModeSelect.value !== 'versus') {
                messageDisplay.textContent = "ãƒœãƒƒãƒˆãŒå®Ÿè¡Œä¸­ã®ãŸã‚ã€æ‰‹å‹•æ“ä½œã¯ã§ãã¾ã›ã‚“ã€‚";
                return;
            }
            if (playerWon || botWon) return;

            const pegId = event.currentTarget.id;
            const pegIndex = parseInt(pegId.replace('peg', '')) - 1;

            if (pegIndex >= 0 && pegIndex <= 2) {
                if (sourcePegIndex === -1) {
                    const topDisk = playerPegElements[pegIndex].querySelector('.disk:last-child');
                    if (topDisk) {
                        if (!isTimerRunning) { 
                            startTimer(); 
                            isTimerRunning = true; 
                            if (gameModeSelect.value === 'versus') {
                                moveQueue = []; 
                                // ãƒãƒ³ãƒ‡æ‰‹æ•°ã«åŸºã¥ã„ã¦ãƒœãƒƒãƒˆã®å‹•ãã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã‚’å‘¼ã³å‡ºã—
                                generateBotMovesWithHandicap(disksCount, 0, 1, 2, botHandicapMoves);
                                
                                if (moveQueue.length > 0) { 
                                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° currentBotSpeedMs ã‚’ä½¿ç”¨
                                    if(currentBotSpeedMs > 0) startBotMoves(currentBotSpeedMs);
                                } else {
                                    console.error("Bot Start Error: Move queue generation failed.");
                                    messageDisplay.textContent = "è­¦å‘Š: ãƒœãƒƒãƒˆã®ç§»å‹•æ‰‹é †ãŒç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚";
                                }
                            }
                        }
                        sourcePegIndex = pegIndex;
                        selectedDisk = topDisk;
                        selectedDisk.classList.add('selected');
                        messageDisplay.textContent = `æ­ ${pegIndex + 1} ã‚’å§‹ç‚¹ã¨ã—ã¦é¸æŠã—ã¾ã—ãŸã€‚ç§»å‹•å…ˆã®æ­ (1, 2, 3) ã‚’ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯æŠ¼ã—ã¦ãã ã•ã„ã€‚`;
                    } else {
                        messageDisplay.textContent = `æ­ ${pegIndex + 1} ã«ã¯å‹•ã‹ã›ã‚‹å††ç›¤ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`;
                    }
                } else {
                    const targetPegIndex = pegIndex;
                    if (sourcePegIndex === targetPegIndex) {
                        resetSelection();
                        messageDisplay.textContent = "å§‹ç‚¹ã¨åŒã˜æ­ã‚’é¸ã³ã¾ã—ãŸã€‚é¸æŠã‚’è§£é™¤ã—ã¾ã™ã€‚";
                        return;
                    }
                    const isSuccess = attemptMove(sourcePegIndex, targetPegIndex);
                    if (isSuccess) { checkWin(); }
                    resetSelection();
                }
            }
        }
        
        function handleKeyPress(event) {
            if (isBotRunning && gameModeSelect.value !== 'versus') return;
            if (playerWon || botWon) return;

            const key = event.key;
            const pegIndex = parseInt(key) - 1;

            if (key === '1' || key === '2' || key === '3') {
                if (sourcePegIndex === -1) {
                    const topDisk = playerPegElements[pegIndex].querySelector('.disk:last-child');
                    if (topDisk) {
                        if (!isTimerRunning) { 
                            startTimer(); 
                            isTimerRunning = true; 
                            if (gameModeSelect.value === 'versus') {
                                moveQueue = [];
                                generateBotMovesWithHandicap(disksCount, 0, 1, 2, botHandicapMoves); 
                                
                                if (moveQueue.length > 0) {
                                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° currentBotSpeedMs ã‚’ä½¿ç”¨
                                    if(currentBotSpeedMs > 0) startBotMoves(currentBotSpeedMs);
                                } else {
                                     console.error("Bot Start Error: Move queue generation failed (Key Press).");
                                     messageDisplay.textContent = "è­¦å‘Š: ãƒœãƒƒãƒˆã®ç§»å‹•æ‰‹é †ãŒç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚";
                                }
                            }
                        }
                        sourcePegIndex = pegIndex;
                        selectedDisk = topDisk;
                        selectedDisk.classList.add('selected');
                        messageDisplay.textContent = `æ­ ${key} ã‚’å§‹ç‚¹ã¨ã—ã¦é¸æŠã—ã¾ã—ãŸã€‚ç§»å‹•å…ˆã®æ­ (1, 2, 3) ã‚’ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯æŠ¼ã—ã¦ãã ã•ã„ã€‚`;
                    } else {
                        messageDisplay.textContent = `æ­ ${key} ã«ã¯å‹•ã‹ã›ã‚‹å††ç›¤ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`;
                    }
                } else {
                    const targetPegIndex = pegIndex;
                    if (sourcePegIndex === targetPegIndex) {
                        resetSelection();
                        messageDisplay.textContent = "å§‹ç‚¹ã¨åŒã˜æ­ã‚’é¸ã³ã¾ã—ãŸã€‚é¸æŠã‚’è§£é™¤ã—ã¾ã™ã€‚";
                        return;
                    }
                    const isSuccess = attemptMove(sourcePegIndex, targetPegIndex);
                    if (isSuccess) { checkWin(); }
                    resetSelection();
                }
            } else if (key === 'Escape') {
                resetSelection();
                messageDisplay.textContent = "é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚å§‹ç‚¹ã®æ­ (1, 2, 3) ã‚’ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯æŠ¼ã—ã¦ãã ã•ã„ã€‚";
            }
        }

        function attemptMove(sourceIndex, targetIndex) {
            const targetPeg = playerPegElements[targetIndex];
            const topDiskOnTarget = targetPeg.querySelector('.disk:last-child');
            const selectedSize = parseInt(selectedDisk.dataset.size);
            const topDiskSize = topDiskOnTarget ? parseInt(topDiskOnTarget.dataset.size) : Infinity;

            if (selectedSize < topDiskSize) {
                selectedDisk.parentNode.removeChild(selectedDisk);
                targetPeg.appendChild(selectedDisk);
                
                playerPegsState[sourceIndex].pop();
                playerPegsState[targetIndex].push(selectedSize);

                moves++;
                movesDisplay.textContent = moves;
                
                if (gameModeSelect.value !== 'versus') {
                    messageDisplay.textContent = `æ­ ${sourceIndex + 1} ã‹ã‚‰æ­ ${targetIndex + 1} ã¸ç§»å‹•ã—ã¾ã—ãŸã€‚`;
                }
                return true;
            } else {
                messageDisplay.textContent = "ãƒ«ãƒ¼ãƒ«é•åã§ã™ï¼å°ã•ã„å††ç›¤ã®ä¸Šã«å¤§ããªå††ç›¤ã¯ç½®ã‘ã¾ã›ã‚“ã€‚";
                return false;
            }
        }

        function resetSelection() {
            if (selectedDisk) {
                selectedDisk.classList.remove('selected');
            }
            selectedDisk = null;
            sourcePegIndex = -1;
        }

        // --- ã‚¿ã‚¤ãƒãƒ¼ã¨ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ  ---
        
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 10); 
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        function updateTimer() {
            const elapsed = Date.now() - startTime;
            const totalSeconds = Math.floor(elapsed / 1000);
            const milliseconds = Math.floor(elapsed % 1000 / 10);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedTime = 
                `${String(minutes).padStart(2, '0')}:` +
                `${String(seconds).padStart(2, '0')}.` +
                `${String(milliseconds).padStart(2, '0')}`;
            timeDisplay.textContent = formattedTime;
        }

        function resetTimerDisplay() {
            stopTimer();
            timeDisplay.textContent = "00:00.00";
        }

        function getBestTime(disks) {
            const key = `hanoi_best_time_${disks}`;
            const storedTime = localStorage.getItem(key);
            const timeValue = parseInt(storedTime, 10);
            return !isNaN(timeValue) && timeValue > 0 ? timeValue : null;
        }

        function setBestTime(disks, timeMs) {
            const key = `hanoi_best_time_${disks}`;
            localStorage.setItem(key, timeMs.toString());
        }

        function formatTime(ms) {
            if (ms === null) return "---";
            const totalSeconds = Math.floor(ms / 1000);
            const milliseconds = Math.floor(ms % 1000 / 10);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:` +
                   `${String(seconds).padStart(2, '0')}.` +
                   `${String(milliseconds).padStart(2, '0')}`;
        }
        
        // --- ãƒœãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯ ---

        /**
         * æœ€å°æ‰‹æ•°ã§ãƒãƒã‚¤ã®å¡”ã‚’è§£ããŸã‚ã®ç§»å‹•æ‰‹é †ã‚’moveQueueã«è¿½åŠ ã™ã‚‹
         */
        function solveHanoi(n, source, auxiliary, destination) {
            if (n === 1) {
                moveQueue.push({ from: source, to: destination });
                return;
            }
            solveHanoi(n - 1, source, destination, auxiliary);
            moveQueue.push({ from: source, to: destination });
            solveHanoi(n - 1, auxiliary, source, destination);
        }

        /**
         * â˜…æ–°è¦å°å…¥æ©Ÿèƒ½: ãƒ¬ãƒ¼ãƒˆã«åŸºã¥ããƒãƒ³ãƒ‡æ‰‹æ•°è¾¼ã¿ã§ãƒœãƒƒãƒˆã®ç§»å‹•æ‰‹é †ã‚’ç”Ÿæˆ
         */
        function generateBotMovesWithHandicap(n, source, auxiliary, destination, addedMoves) {
            // ãƒœãƒƒãƒˆã®åˆæœŸçŠ¶æ…‹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã«è¤‡è£½
            let simState = JSON.parse(JSON.stringify(botPegsState));

            // æœ€å°æ‰‹æ•°ã§ã®ç§»å‹•æ‰‹é †ã‚’ã™ã¹ã¦ç”Ÿæˆ
            moveQueue = [];
            solveHanoi(n, source, auxiliary, destination);
            
            if (addedMoves <= 0) return;

            // ãƒãƒ³ãƒ‡ã‚’é©ç”¨: æœ€å°æ‰‹æ•°ãƒ ãƒ¼ãƒ–ã®é–“ã«ã€ã‚µã‚¤ã‚º1ã®å††ç›¤ã®ç„¡é§„ãªç§»å‹•ã‚’æŒ¿å…¥
            let tempQueue = [];
            let wastedMoves = 0;
            
            // å††ç›¤1ã¯å¸¸ã«å‹•ã‹ã›ã‚‹ã®ã§ã€ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦ç„¡é§„ãªç§»å‹•ã‚’æŒ¿å…¥
            const DISK_SIZE_1 = 1;
            
            for (let j = 0; j < moveQueue.length && wastedMoves < addedMoves; j++) {
                const move = moveQueue[j];
                
                // æœ€å°æ‰‹æ•°ãƒ ãƒ¼ãƒ–ã‚’å®Ÿè¡Œ (ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)
                const movedDiskSize = simState[move.from].pop(); 
                simState[move.to].push(movedDiskSize);
                tempQueue.push(move); 

                // ç„¡é§„ãªç§»å‹•ã®æŒ¿å…¥
                if (wastedMoves < addedMoves) {
                    const disk1Location = simState.findIndex(peg => peg.includes(DISK_SIZE_1));
                    
                    if (disk1Location !== -1) {
                        let wasteTarget = (disk1Location + 1) % 3; 
                        
                        // ç§»å‹•ãƒ«ãƒ¼ãƒ«ã«å¾“ã„ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ­ã®æœ€ä¸Šä½å††ç›¤ã‚ˆã‚Šå°ã•ããªã‘ã‚Œã°ãªã‚‰ãªã„ (ã‚µã‚¤ã‚º1ã¯å¸¸ã«OK)
                        // ãŸã ã—ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ­ã«å††ç›¤1ãŒãªã„ã“ã¨ã‚’ç¢ºèªï¼ˆç§»å‹•ã—ãªã„æ­ã‚’é¸ã¶ï¼‰
                        
                        // åˆ¥ã®æ­ (1, 2) ã®ã†ã¡ã€ã‚µã‚¤ã‚º1ãŒç¾åœ¨ã„ãªã„æ­ã‚’é¸ã¶
                        let possibleTargets = [0, 1, 2].filter(p => p !== disk1Location);
                        
                        // ã©ã¡ã‚‰ã«å‹•ã‹ã™ã‹
                        let targetPegIndex = possibleTargets[0];
                        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ­ã®æœ€ä¸Šä½å††ç›¤ã‚µã‚¤ã‚º
                        const topDiskSizeTarget = simState[targetPegIndex].length > 0 ? simState[targetPegIndex][simState[targetPegIndex].length - 1] : Infinity;

                        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ­ã«å††ç›¤1ã‚ˆã‚Šã‚‚å¤§ããªå††ç›¤ãŒã‚ã‚‹ã‹ã€ã¾ãŸã¯ç©ºã§ã‚ã‚‹ã‹ã‚’ç¢ºèª
                        if (topDiskSizeTarget < DISK_SIZE_1) {
                            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ­ã«å††ç›¤1ã‚ˆã‚Šå°ã•ã„å††ç›¤ãŒã‚ã‚‹å ´åˆã¯ã€ã‚‚ã†ä¸€æ–¹ã®æ­ã‚’è©¦ã™
                             targetPegIndex = possibleTargets[1];
                        }
                        
                        if (disk1Location !== targetPegIndex) {
                            
                            // ç„¡é§„ãªç§»å‹• (å††ç›¤1ã‚’å‹•ã‹ã™)
                            tempQueue.push({ from: disk1Location, to: targetPegIndex });
                            
                            // ç›¤é¢çŠ¶æ…‹ã‚‚æ›´æ–°
                            simState[disk1Location].pop(); 
                            simState[targetPegIndex].push(DISK_SIZE_1);
                            
                            wastedMoves++;
                        }
                    }
                }
            }
            
            // æœ€å¾Œã«è¿½åŠ ã®ç„¡é§„ãªç§»å‹•ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆ
            while(wastedMoves < addedMoves) {
                // å††ç›¤1ã®ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
                const disk1Location = simState.findIndex(peg => peg.includes(DISK_SIZE_1));
                if (disk1Location === -1) break; // ã‚¨ãƒ©ãƒ¼
                
                // åˆ¥ã®æ­ (1, 2) ã®ã†ã¡ã€ã‚µã‚¤ã‚º1ãŒç¾åœ¨ã„ãªã„æ­ã‚’é¸ã¶
                let possibleTargets = [0, 1, 2].filter(p => p !== disk1Location);
                let targetPegIndex = possibleTargets[0];
                const topDiskSizeTarget = simState[targetPegIndex].length > 0 ? simState[targetPegIndex][simState[targetPegIndex].length - 1] : Infinity;

                if (topDiskSizeTarget < DISK_SIZE_1) {
                     targetPegIndex = possibleTargets[1];
                }
                
                if (disk1Location !== targetPegIndex) {
                    tempQueue.push({ from: disk1Location, to: targetPegIndex });
                    simState[disk1Location].pop(); 
                    simState[targetPegIndex].push(DISK_SIZE_1);
                    wastedMoves++;
                } else {
                    break; // å‹•ã‹ã›ã‚‹å ´æ‰€ãŒãªã„ (åŸºæœ¬çš„ã«ã¯ç™ºç”Ÿã—ãªã„)
                }
            }

            // æœ€å°æ‰‹æ•°ãƒ ãƒ¼ãƒ–ã‚’ã€ãƒãƒ³ãƒ‡è¾¼ã¿ã®ãƒ ãƒ¼ãƒ–ã§ç½®ãæ›ãˆã‚‹
            moveQueue = tempQueue;
            console.log(`Bot handicap applied: ${minMoves} moves + ${moveQueue.length - minMoves} wasted moves = ${moveQueue.length} total.`);
        }
        
        function startBot() {
            const gameMode = gameModeSelect.value;
            
            if (gameMode === 'manual') return;

            if(playerWon || botWon || isBotRunning) {
                 resetGame();
            }

            if (gameMode === 'versus') {
                // initGame()ã§è¨ˆç®—ã•ã‚ŒãŸé€Ÿåº¦ã¨æ‰‹æ•°æƒ…å ±ã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å†è¡¨ç¤º
                const botTotalMoves = minMoves + botHandicapMoves;
                messageDisplay.textContent = `âš”ï¸ å¯¾æˆ¦æº–å‚™å®Œäº†ï¼ç¾åœ¨ã®ãƒ¬ãƒ¼ãƒˆ ${playerRate}ã€‚ãƒœãƒƒãƒˆã¯ ${botTotalMoves}æ‰‹ (${botHandicapMoves}æ‰‹ãƒãƒ³ãƒ‡) ã¨é€Ÿåº¦ ${currentBotSpeedMs}ms ã§ç«¶ã„ã¾ã™ã€‚å®Ÿè¡Œãƒœã‚¿ãƒ³ã§é–‹å§‹ã€‚`;
                return;
            }
            
            // ãƒœãƒƒãƒˆå˜ç‹¬ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ
            isBotRunning = true;
            moveQueue = [];
            solveHanoi(disksCount, 0, 1, 2); // ãƒœãƒƒãƒˆå˜ç‹¬ãƒ¢ãƒ¼ãƒ‰ã¯å¸¸ã«æœ€å°æ‰‹æ•°

            const selectedSpeedMs = parseInt(botSpeedSelect.value, 10);
            const isSimulationMode = selectedSpeedMs === 0;

            if (isSimulationMode) {
                startTimer();
                moves = moveQueue.length; 
                movesDisplay.textContent = moves;
                moveQueue = []; 
                checkWin(true); 
                isBotRunning = false;
                return;
            }
            
            startTimer();
            startBotMoves(selectedSpeedMs);
            messageDisplay.textContent = "ğŸ¤– ãƒœãƒƒãƒˆãŒæœ€å°æ‰‹æ•°ã§ã®è§£æ±ºã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚";
        }

        /**
         * ãƒœãƒƒãƒˆã®ç§»å‹•å®Ÿè¡Œã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«é–‹å§‹
         * @param {number} speedMs - ãƒœãƒƒãƒˆã®ç§»å‹•é–“éš” (ms)
         */
        function startBotMoves(speedMs) {
            if (botInterval) clearInterval(botInterval);

            const gameMode = gameModeSelect.value;
            const isBotOnly = gameMode === 'bot_only';
            
            const targetPegs = isBotOnly ? playerPegElements : botPegElements; 
            const targetState = isBotOnly ? playerPegsState : botPegsState; 
            
            // â˜…ä¿®æ­£ç‚¹: å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° (initGameã§è¨ˆç®—æ¸ˆã¿) ã‚’ä½¿ç”¨
            let actualSpeedMs = speedMs;
            if (gameMode === 'versus') {
                 actualSpeedMs = currentBotSpeedMs;
            }

            const animationDelay = 150; 
            const shouldSkipAnimation = actualSpeedMs <= 150; 
            isBotRunning = true; 
            
            botInterval = setInterval(() => {
                if (playerWon && gameMode === 'versus') {
                    clearInterval(botInterval);
                    isBotRunning = false;
                    return;
                }
                
                if (moveQueue.length === 0 || botWon) {
                    clearInterval(botInterval);
                    isBotRunning = false;
                    return;
                }
                
                const nextMove = moveQueue.shift();
                
                const sourcePeg = targetPegs[nextMove.from];
                const targetPeg = targetPegs[nextMove.to];
                
                const diskElement = sourcePeg.querySelector('.disk:last-child');
                
                if (diskElement) {
                    const diskSize = targetState[nextMove.from].pop();
                    targetState[nextMove.to].push(diskSize);
                    
                    if (shouldSkipAnimation) {
                        diskElement.parentNode.removeChild(diskElement);
                        targetPeg.appendChild(diskElement);
                    } else {
                        diskElement.classList.add('selected');
                        setTimeout(() => {
                            diskElement.parentNode.removeChild(diskElement);
                            targetPeg.appendChild(diskElement);
                            diskElement.classList.remove('selected');
                        }, animationDelay);
                    }

                    if (moveQueue.length === 0) {
                        if (isBotOnly) {
                            checkWin(true); 
                        } else {
                            botWinCheck(); 
                        }
                        
                        clearInterval(botInterval);
                        isBotRunning = false;
                    }
                } else {
                    console.error(`Bot Error: Source peg ${nextMove.from + 1} is empty but move queue suggests a move. Stopping bot.`);
                    clearInterval(botInterval);
                    isBotRunning = false;
                    messageDisplay.textContent = "ğŸš¨ ãƒœãƒƒãƒˆå‹•ä½œã‚¨ãƒ©ãƒ¼ï¼šäºˆæœŸã›ã¬ç›¤é¢çŠ¶æ…‹ã®ãŸã‚åœæ­¢ã—ã¾ã—ãŸã€‚ãƒªã‚»ãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚";
                }

            }, actualSpeedMs); 
        }


        // --- å‹åˆ©åˆ¤å®šã¨ãƒ¬ãƒ¼ãƒˆæ›´æ–° ---
        
        function checkWin(isSimulation = false) {
            if (playerWon || botWon) return; 

            const gameMode = gameModeSelect.value;
            const isPlayerWin = (playerPegsState[1].length === disksCount) ||
                                (playerPegsState[2].length === disksCount);

            if (isPlayerWin || isSimulation) {
                playerWon = true; 
                stopTimer();
                
                const finalTimeMs = Date.now() - startTime;
                let winMessage = '';
                let bestTimeMessage = '';

                if (gameMode === 'versus') {
                    if (botInterval) clearInterval(botInterval); 
                    updateRate(true); 
                    messageDisplay.textContent = `ğŸ† ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‹åˆ©ï¼ãƒ¬ãƒ¼ãƒˆãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ (${rateDisplayElement.textContent})ã€‚`;
                } else {
                    winMessage = `ğŸ‰ ${isSimulation ? 'ãƒœãƒƒãƒˆãŒ' : 'ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼'} ${disksCount}å€‹ã®å††ç›¤ã‚’ç§»å‹•ã•ã›ã¾ã—ãŸã€‚`;
                    
                    const actualMoves = isSimulation ? minMoves : moves;
                    const minMovesStr = minMovesDisplay.textContent;
                    if (actualMoves === minMoves) {
                        winMessage += ` æœ€å°æ‰‹æ•° (${minMovesStr}æ‰‹) ã§ã‚¯ãƒªã‚¢ã§ã™ï¼`;
                    } else {
                        winMessage += ` æ‰‹æ•°: ${actualMoves}å› (æœ€å°æ‰‹æ•°: ${minMovesStr}å›)`;
                    }

                    const selectedSpeedMs = parseInt(botSpeedSelect.value, 10);
                    const isBotTime = isSimulation || (isBotRunning && selectedSpeedMs <= 150); 

                    bestTimeMessage = ` ğŸ† ã‚¿ã‚¤ãƒ : ${formatTime(finalTimeMs)}`;

                    if (!isBotTime) {
                        const currentBestTimeMs = getBestTime(disksCount);
                        if (currentBestTimeMs === null || finalTimeMs < currentBestTimeMs) {
                            setBestTime(disksCount, finalTimeMs);
                            bestTimeDisplay.textContent = formatTime(finalTimeMs);
                            bestTimeMessage += " (âœ¨ **NEW RECORD!**)";
                        } else {
                            bestTimeMessage += ` (ãƒ™ã‚¹ãƒˆ: ${formatTime(currentBestTimeMs)})`;
                        }
                    } else {
                        bestTimeMessage += ` (è¨˜éŒ²å¯¾è±¡å¤–: é«˜é€Ÿãƒœãƒƒãƒˆ)`;
                    }

                    winMessage += bestTimeMessage;
                    messageDisplay.textContent = winMessage;
                }
            }
        }

        function botWinCheck() {
            if (playerWon || botWon) return; 
            
            const isBotWin = (botPegsState[1].length === disksCount) || (botPegsState[2].length === disksCount);

            if (isBotWin) {
                botWon = true; 
                stopTimer();
                
                if (!playerWon) {
                    updateRate(false); 
                    messageDisplay.textContent = `ğŸ¤– ãƒœãƒƒãƒˆå‹åˆ©ï¼ãƒ¬ãƒ¼ãƒˆãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ (${rateDisplayElement.textContent})ã€‚`;
                }
            }
        }

        /**
         * ãƒ¬ãƒ¼ãƒˆã‚’æ›´æ–°ã—ã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã™ã‚‹
         * @param {boolean} didPlayerWin - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå‹ã£ãŸã‹ã©ã†ã‹
         */
        function updateRate(didPlayerWin) {
            const K = RATE_K; 
            
            const botBaseRate = 600; 
            const diskFactor = Math.min(60, disksCount - 3) * 15; 
            const botVirtualRate = botBaseRate + diskFactor; 

            // æœŸå¾…å‹ç‡ We
            const expectedScore = 1 / (1 + Math.pow(10, (botVirtualRate - playerRate) / 400));
            // å®Ÿéš›ã®çµæœ W (å‹åˆ©ãªã‚‰ 1, æ•—åŒ—ãªã‚‰ 0)
            const actualScore = didPlayerWin ? 1 : 0;
            
            // ãƒ¬ãƒ¼ãƒˆå¤‰å‹• = K * (W - We)
            const rateChange = Math.round(K * (actualScore - expectedScore));
            
            const newRate = playerRate + rateChange;

            // ãƒ¬ãƒ¼ãƒˆã®ä¸‹é™ã‚’100ã«è¨­å®š
            playerRate = Math.max(100, newRate); 
            localStorage.setItem('hanoi_player_rate', playerRate.toString());
            rateDisplayElement.textContent = playerRate;
        }

        // --- ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ ä¸€è¦§è¡¨ç¤º ---
        function displayBestTimes() {
            const container = document.getElementById('best-time-list-container');
            const records = [];

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                
                if (key && key.startsWith('hanoi_best_time_')) {
                    const disks = parseInt(key.replace('hanoi_best_time_', ''), 10);
                    const timeMs = parseInt(localStorage.getItem(key), 10);
                    
                    if (!isNaN(disks) && !isNaN(timeMs) && timeMs > 0) {
                        records.push({
                            disks: disks,
                            timeMs: timeMs,
                            formattedTime: formatTime(timeMs)
                        });
                    }
                }
            }

            if (records.length === 0) {
                container.innerHTML = '<p>ã¾ã ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ ã®è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
                return;
            }

            records.sort((a, b) => a.disks - b.disks);

            let tableHTML = `
                <h3>ğŸ† è¨˜éŒ²ã•ã‚ŒãŸãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ ä¸€è¦§</h3>
                <table class="best-time-table">
                    <thead>
                        <tr>
                            <th>å††ç›¤æ•°</th>
                            <th>æœ€å°æ‰‹æ•°</th>
                            <th>ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ </th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            records.forEach(record => {
                const minMoves = Math.pow(2, record.disks) - 1;
                let minMovesStr = minMoves.toString();
                
                if (record.disks > 25) { 
                    minMovesStr = `2^${record.disks} - 1`;
                } else if (minMovesStr.length > 15) {
                    minMovesStr = minMoves.toExponential(2);
                }
                
                tableHTML += `
                    <tr>
                        <td>${record.disks}æš</td>
                        <td>${minMovesStr}æ‰‹</td>
                        <td>${record.formattedTime}</td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            
            tableHTML += '<button onclick="clearAllBestTimes()" style="margin-top: 10px; background-color: #dc3545;">ã™ã¹ã¦ã®è¨˜éŒ²ã‚’å‰Šé™¤</button>';

            container.innerHTML = tableHTML;
        }

        function clearAllBestTimes() {
            if (confirm("æœ¬å½“ã«ã™ã¹ã¦ã®ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¨˜éŒ²ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) {
                let keysToDelete = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('hanoi_best_time_')) {
                        keysToDelete.push(key);
                    }
                }
                
                keysToDelete.forEach(key => localStorage.removeItem(key));
                
                initGame(); 
                displayBestTimes(); 
                alert("ã™ã¹ã¦ã®ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¨˜éŒ²ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚");
            }
        }
    </script>

</body>
</html>
